## Recall

Hash:

- Completely deterministic (not luck/random stuff)
- input : var length
- output : fix length
- 少 collision
- 難 invert

In CS, by default: $log(n) = log_2(n) \neq log_{10}(n)$ 

## Merkle Trees

fingerprinting:

- hash -> "fingerprint" of a file/data
- multiple files OK : $y	=H(x_1, x_2, x_3, ... x_n)$
- understood using Merkle Tree
    - < See PPT visualization >

Merkle Tree:

- note: those $x_i$ (leafs) are hashes of single files
- each node : same size (eg. 256 bits)

- for a tree w/: n elements (aka leafs)
    - prove membership of $x_i$ -> needs log(n) given hashes (neighbors) **IN ADDITION to** the nodes in the path(root -> $x_i$)
        In L04 PPT P.12,
        - n = 8
        - from root to target have 4 nodes
        - So, No. of green nodes = log(8) + 4 = 7
        - (size of proof = 256 bits * 7)
    - update $x_i$ -> needs log(n) hashing action **IN ADDITION to** hashing $x_i$ 







